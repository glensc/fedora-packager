#!/usr/bin/python

# fedpkg-make-pull:
# Licensed under the new-BSD license (http://www.opensource.org/licenses/bsd-license.php)
# Copyright (C) 2010 Red Hat, Inc.
# Written by Colin Walters <walters@verbum.org>
#
# Using a key in the .spec file "#VCS", support various operations using
# the upstream version control repository:
#
# $ make-pull 
#   Create a .srpm of the latest upstream code
# $ make-pull --apply
#   Patch the existing .spec, sources files for the latest upstream
# $ make-pull --tag 0xdeadbeef
#   Create a .srpm from the tag/branch identifier
# $ make-pull --apply --patch 0xdeadbeef
#   Update the .spec file to include patch 0xdeadbeef from upstream
#

import os
import sys
import re
import urlparse
import getopt
import subprocess
import shutil
import hashlib
import datetime

from pyfedpkg.lame_vcs_abstraction import Vcs
from pyfedpkg.build_intelligence import BuildSystem
from pyfedpkg.spec import Spec	
   
def _require_checkout(spec, vcs, vcsdir, verbose=False):
    if os.path.exists(vcsdir):
        if verbose:
            print "VCS directory %r already exists" % (vcsdir, )
        return
    print "Checking out from %r into new directory %r" % (vcs.get_url(), vcsdir)
    vcs.checkout(vcsdir)

def command_checkout(spec, vcs, vcsdir, args=[], opts={}):
    _require_checkout(spec, vcs, vcsdir, verbose=True)
    
def command_pull(spec, vcs, vcsdir, args=[], opts={}):
    if not os.path.exists(vcsdir):
        command_checkout(spec, vcs, vcsdir, args=args, opts=opts)
    print "Updating from %r existing directory %r" % (vcs.get_url(), vcsdir)
    vcs.switch_to_revision(vcsdir, None)
    oldid = vcs.get_id(vcsdir)
    vcs.update(vcsdir)
    newid = vcs.get_id(vcsdir)
    if oldid == newid and not opts['force']:
        print "No changes upstream"
        if opts['statusfile'] is not None:
            f = open(opts['statusfile'], 'w')
            f.write('unchanged')
            f.close()
        sys.exit(0)

def command_pull_retarget(spec, vcs, vcsdir, args=[], opts={}):
    command_pull(spec, vcs, vcsdir, args=args, opts=opts)
    command_retarget(spec, vcs, vcsdir, args=['HEAD'], opts=opts)
        
def command_retarget(spec, vcs, vcsdir, args=[], opts={}):
    _require_checkout(spec, vcs, vcsdir)
    
    if len(args) != 1:
        print "Usage: fedpkg-vcs retarget REVISION"
        sys.exit(1)
        
    target = args[0]
    
    vcs.switch_to_revision(vcsdir, target)
    
    try:
        _impl_retarget(spec, vcs, vcsdir, args=[target], opts=opts)
    finally:
        vcs.switch_to_revision(vcsdir, None)

def _impl_retarget(spec, vcs, vcsdir, args=[], opts={}):
    name = spec.get_name()
    version = spec.get_version()
    abbrev_id = vcs.get_abbreviated_id(vcsdir)

    snapshot_dirname = '%s-%s%s%s' % (name, version, vcs.get_scheme(), abbrev_id)
    snapshot_archivename = snapshot_dirname + '.tar.bz2'
    subprocess.check_call(['tar', '-cj', r'--transform=s,^\.,' + snapshot_dirname + ',', '-f', '../' + snapshot_archivename, '.'], cwd=vcsdir)
    
    buildsys = BuildSystem.new_from_directory(vcsdir)
    if buildsys is None:
        print "WARNING: Unrecognized buildsystem in directory %r" % (vcsdir, )
    else:
        spec.add_buildrequires(buildsys.get_bootstrap_buildrequires())
        spec.substitute(buildsys.get_substitutions())

    spec.set_source(snapshot_dirname, snapshot_archivename)
    now = datetime.datetime.now()
    alphatag = "%s%s%s" % (now.strftime("%Y%m%d"), vcs.vcstype, abbrev_id)
    spec.increment_release_snapshot(alphatag)
    spec.save()
    
    snapshot_md5 = hashlib.md5()
    f = open(snapshot_archivename)
    b = f.read(8192)
    while b != '':
        snapshot_md5.update(b)
        b = f.read(8192)
    f.close()
        
    snapshot_md5 = snapshot_md5.hexdigest()
    
    f = open('sources', 'w')
    f.write(snapshot_md5)
    f.write('  ')
    f.write(snapshot_archivename)
    f.write('\n')
    f.close()
            
    print "Updated %s and sources file" % (spec, )
    print "If you want to upload to Fedora, you'll need to run:"
    print "  make upload FILE=%s" % (snapshot_archivename, )
    print "  cvs commit && make tag build"
    if opts['statusfile'] is not None:
        f = open(opts['statusfile'], 'w')
        f.write('updated')
        f.close()
        
def command_cherrypick(spec, vcs, vcsdir, args=[], opts={}):
    if len(args) != 1:
        print "Usage: git-vcs cherrypick COMMITID"
        sys.exit(1)
        
    commitid = args[0]

    filename = vcs.get_commit_summary_as_filename(vcsdir, commitid)
    filename += '.patch'
    if os.path.exists(filename):
        print "Error: File %r already exists" % (filename, )
        sys.exit(1)
    vcs.get_commit_as_patch(vcsdir, commitid, filename)
    
    spec.add_patch(filename)
    spec.save()
    subprocess.check_call(['cvs', 'add', filename])
    print "Successfully added patch %r" % (filename, )
    
def main():
    valid_commands = { 'checkout': (command_checkout, "Perform an initial checkout of upstream revision control"),
                       'pull': (command_pull, "Pull the latest upstream code"),
                       'retarget': (command_retarget, "Modify spec to use given commit id"),
                       'pull-retarget': (command_pull_retarget, "Pull the latest upstream, modify spec file to use it"),
                       'cherrypick': (command_cherrypick, "Apply a specific commit id as a patch to specfile") }
    def usage(ecode):
        print ""
        print "Usage: fedpkg-vcs COMMAND [-f]"
        print "Valid commands:"
        for cmdname in sorted(valid_commands):
            (cmdfunc, description) = valid_commands[cmdname]
            print "  %s: %s" % (cmdname, description)
        sys.exit(ecode)
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'f', ['force', 'status-file=', 'help'])
    except getopt.GetoptError, e:
        print unicode(e)
        usage(1)
        
    if len(args) < 1:
        usage(1)

    cmd = args[0]
    if cmd == 'pull-update':
        cmd = 'pull-retarget'
    if not cmd in valid_commands:
        usage(1)
        
    force = False
    opt_statusfile = None
    for o, a in opts:
        if o in ('-f', '--force'):
            force = True
        elif o in ('--status-file', ):
            opt_statusfile = a
        elif o in ('--help', ):
            usage(0)

    targetspec = None
    for filename in os.listdir('.'):
        if filename.endswith('.spec'):
            targetspec = filename
    
    if targetspec is None:
        sys.stderr.write("Couldn't find spec file\n")
        sys.exit(1)
    spec = Spec(targetspec)

    f = open('sources')
    lines = f.readlines()
    f.close()
    if len(lines) != 1:
        print "Must have exactly one source in sources file"
        sys.exit(1)
    
    try:
        vcsurl = spec.get_vcs()
    except ValueError, e:
        sys.stderr.write(unicode(e) + '\n')
        sys.exit(1)
    
    vcs = Vcs.new_from_spec(vcsurl)
    vcsdir = '%s.%s' % (spec.get_name(), vcs.get_scheme())
 
    opts = {'force': force,
            'statusfile': opt_statusfile}
    valid_commands[cmd][0](spec, vcs, vcsdir, args=args[1:], opts=opts)
   
    sys.exit(0)
        
if __name__ == '__main__':
    main()
